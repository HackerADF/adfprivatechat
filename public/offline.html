<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="icon" href="https://cdn.glitch.global/69264440-8ac3-4147-9e23-e5d81d9b7ac1/projectOffline.webp?v=1745382333821" type="image/x-icon">
  <title>Offline | ADF Private Chat</title>
  <link rel="stylesheet" href="/style.css">
<style>
	canvas {
		display: flex;
		position: relative;
		border: 5px solid  #ff0033;
		margin: auto;
		top: 0;
		bottom: 0;
		right: 100;
		left: 0;
	}
  body {
    background: #0e0e0e;
    color: #ff0033;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    margin: 0;
    position: relative;
  }

  .flicker-container {
    text-align: center;
    animation: fadeIn 2s ease-in;
  }

  .flicker-404 {
    font-size: 6rem;
    font-weight: bold;
    color: #ff0033;
    text-shadow: 0 0 10px #ff0033, 0 0 30px #ff0033;
    animation: strobe 3.2s ease-in-out infinite;
  }

  .message {
    margin-top: 20px;
    font-size: 1.2rem;
    color: #aaa;
  }

  @keyframes strobe {
    0%, 100% {
      opacity: 1;
      text-shadow:
        0 0 10px #ff0033,
        0 0 30px #ff0033,
        0 0 60px #ff0033;
    }
    50% {
      opacity: 0.3;
      text-shadow:
        0 0 3px #ff0033,
        0 0 5px #ff0033;
    }
  }

  @keyframes fadeIn {
    0% {
      opacity: 0;
      transform: translateY(30px);
    }
    100% {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .home-link {
    display: inline-block;
    margin-top: 30px;
    padding: 10px 20px;
    color: #000;
    background: #ff0033;
    border-radius: 5px;
    text-decoration: none;
    font-weight: bold;
    transition: background 0.3s ease;
  }

  .home-link:hover {
    background: #cc002a;
  }

  body::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -2;
    background: #0e0e0e;
    overflow: hidden;
  }

  body::after {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;
    pointer-events: none;
    background-image: 
      repeating-linear-gradient(
        135deg,
        rgba(255, 0, 51, 0.1) 0px,
        rgba(255, 0, 51, 0.15) 1px,
        transparent 2px,
        transparent 80px
      );
    animation: animate-lines 20s linear infinite, pulse-glow 6s ease-in-out infinite;
    background-size: 100% 200%;
    filter: drop-shadow(0 0 4px #ff0033);
    opacity: 0.5;
  }

  @keyframes animate-lines {
    0% {
      background-position: 0% 0%;
    }
    100% {
      background-position: 0% 100%;
    }
  }

  @keyframes pulse-glow {
    0%, 100% {
      opacity: 0.4;
      filter: drop-shadow(0 0 2px #ff0033);
    }
    50% {
      opacity: 0.8;
      filter: drop-shadow(0 0 6px #ff0033);
    }
  }
</style>
</head>
<body>
  <div class="flicker-container">
    <div class="flicker-404">Offline</div>
    <div class="message">The server is currently unavailable. Please try again later.</div>
    <a class="home-link" href="/login">Try Again</a>
<body>
<script>
var
COLS = 26,
ROWS = 26,
EMPTY = 0,
SNAKE = 1,
FRUIT = 2,
LEFT  = 0,
UP    = 1,
RIGHT = 2,
DOWN  = 3,
KEY_LEFT  = 37,
KEY_UP    = 38,
KEY_RIGHT = 39,
KEY_DOWN  = 40,
canvas,	  
ctx,	  
keystate, 
frames,   
score;	  
 
grid = {
 
	width: null,  
	height: null, 
	_grid: null,  
 
	
	init: function(d, c, r) {
		this.width = c;
		this.height = r;
 
		this._grid = [];
		for (var x=0; x < c; x++) {
		this._grid.push([]);
		for (var y=0; y < r; y++) {
		this._grid[x].push(d);
		}
		}
	},
 
	
	set: function(val, x, y) {
		this._grid[x][y] = val;
	},
 
	
	get: function(x, y) {
		return this._grid[x][y];
	}
}
 
 
snake = {
 
	direction: null, 
	last: null,	 
	_queue: null,	
 
	
	init: function(d, x, y) {
		this.direction = d;
 
		this._queue = [];
		this.insert(x, y);
	},
 
	
	insert: function(x, y) {
		
		this._queue.unshift({x:x, y:y});
		this.last = this._queue[0];
	},
 
	
	remove: function() {
		
		return this._queue.pop();
	}
};
 
 
function setFood() {
	var empty = [];
	
	for (var x=0; x < grid.width; x++) {
		for (var y=0; y < grid.height; y++) {
		if (grid.get(x, y) === EMPTY) {
		empty.push({x:x, y:y});
		}
		}
	}
	
	var randpos = empty[Math.round(Math.random()*(empty.length - 1))];
	grid.set(FRUIT, randpos.x, randpos.y);
}
 
 
function main() {
	
	canvas = document.createElement("canvas");
	canvas.width = COLS*20;
	canvas.height = ROWS*20;
	ctx = canvas.getContext("2d");
	
	document.body.appendChild(canvas);
 
	
	ctx.font = "12px Helvetica";
 
	frames = 0;
	keystate = {};
	
	document.addEventListener("keydown", function(evt) {
		keystate[evt.keyCode] = true;
	});
	document.addEventListener("keyup", function(evt) {
		delete keystate[evt.keyCode];
	});
 
	
	init();
	loop();
}
 
 
function init() {
	score = 0;
 
	grid.init(EMPTY, COLS, ROWS);
 
	var sp = {x:Math.floor(COLS/2), y:ROWS-1};
	snake.init(UP, sp.x, sp.y);
	grid.set(SNAKE, sp.x, sp.y);
 
	setFood();
}
 
 
function loop() {
	update();
	draw();
	
	window.requestAnimationFrame(loop, canvas);
}
 
 
function update() {
	frames++;
 
	
	if (keystate[KEY_LEFT] && snake.direction !== RIGHT) {
	snake.direction = LEFT;
	}
	if (keystate[KEY_UP] && snake.direction !== DOWN) {
	snake.direction = UP;
	}
	if (keystate[KEY_RIGHT] && snake.direction !== LEFT) {
	snake.direction = RIGHT;
	}
	if (keystate[KEY_DOWN] && snake.direction !== UP) {
	snake.direction = DOWN;
	}
 
	
	if (frames%7 === 0) {
		
	var nx = snake.last.x;
	var ny = snake.last.y;
 
		
	switch (snake.direction) {
	case LEFT:
	nx--;
	break;
	case UP:
	ny--;
	break;
	case RIGHT:
	nx++;
	break;
	case DOWN:
	ny++;
	break;
	}
 
		
	if (0 > nx || nx > grid.width-1  ||
	0 > ny || ny > grid.height-1 ||
	grid.get(nx, ny) === SNAKE
	) {
	return init();
	}
 
	if (grid.get(nx, ny) === FRUIT) {
		
	score++;
	setFood();
	} else {
		
	var tail = snake.remove();
	grid.set(EMPTY, tail.x, tail.y);
	}
 
	grid.set(SNAKE, nx, ny);
	snake.insert(nx, ny);
	}
}
 
 
function draw() {
	
	var tw = canvas.width/grid.width;
	var th = canvas.height/grid.height;
	
	for (var x=0; x < grid.width; x++) {
	for (var y=0; y < grid.height; y++) {
		
	switch (grid.get(x, y)) {
	case EMPTY:
	ctx.fillStyle = "#fff";
	break;
	case SNAKE:
	ctx.fillStyle = "#333";
	break;
	case FRUIT:
	ctx.fillStyle = "#009BFF";
	break;
	}
	ctx.fillRect(x*tw, y*th, tw, th);
	}
	}
	
	ctx.fillStyle = "#000";
	ctx.fillText("SCORE: " + score, 10, canvas.height-10);
}
 
 
main();
</script>
  </div>
</body>
</html>

